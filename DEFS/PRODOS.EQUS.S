;-*-Mode:Merlin-*-;; ProDOS equates.;; This file contains the equates for the ProDOS system; globals page, as well as miscellaneous equates for; ProDOS.;; Function equates:;QuitProg = $65 ;quit this application.ReadBlock = $80 ;read a single block of disk.WriteBlock = $81 ;write a single block of disk.GetDateTime = $82 ;return Date and Time.CreateEnt = $C0 ;create a file or directory.DestroyEnt = $C1 ;delete a file or directory.RenameEnt = $C2 ;rename a file.SetFileInfo = $C3GetFileInfo = $C4VolsOnLine = $C5SetDefPrefix = $C6GetDefPrefix = $C7OpenFile = $C8NewLine = $C9ReadFile = $CAwriteFile = $CBCloseFile = $CCFlushVol = $CDSetFilePos = $CEGetFilePos = $CFSetEndOfFile = $D0GetEndOfFile = $D1GetBuffer = $D3SetBuffer = $DF;; Function error codes.;er_NoError = $00er_BadFunc = $01er_BadParms = $04er_NoIntRoom = $25er_BadDisk = $27er_NoDevice = $28er_WriteProt = $2Ber_VolChanged = $2Eer_BadPath = $40er_FilesMaxed = $42er_BadRefNum = $43er_NoSuchPath = $44er_NoSuchVol = $45 ;actually, Volume Not Mounted.er_FileNotFnd = $46er_DupFile = $47er_DiskFull = $48er_DirFull = $49er_BadVer = $4Aer_BadFileTyp = $4Ber_EndOfFile = $4Cer_PosPastEOF = $4Der_Access = $4Eer_FileOpen = $50 ;file is already open.er_BadFileCnt = $51 ;what the fuck does this mean?er_NotProdos = $52 ;this isn't a ProDOS disk.er_BadParam = $53er_VCBOvflw = $55 ;don't ask me (volume control block?)er_BadBuffer = $56 ;buffer is in protected RAM.er_DupVolume = $57er_BadBitmap = $58 ;hope and pray that you don't get this one.;;  ProDOS system globals page.;MLI  = $BF00  ;entry to the MLI.SysDeath = MLI+3  ;call system death handler.ReadClock = SysDeath+3 ;jump to clock routine.SysError = ReadClock+3 ;call system error handler.SysDeath1 = SysError+3 ;call system death handler.SysErrorByte = SysDeath1+3 ;the error code.;DriverList = SysErrorByte+1 ;device driver address.;drvr_RAM = DriverList ;/RAM driverdrvr_S1D1 = drvr_RAM+2 ;slot 1, drive 1.drvr_S2D1 = drvr_S1D1+2 ;slot 2, drive 1.drvr_S3D1 = drvr_S2D1+2 ;slot 3, drive 1.drvr_S4D1 = drvr_S3D1+2 ;slot 4, drive 1.drvr_S5D1 = drvr_S4D1+2 ;slot 5, drive 1.drvr_S6D1 = drvr_S5D1+2 ;slot 6, drive 1.drvr_S7D1 = drvr_S6D1+2 ;slot 7, drive 1.drvr_S0D2 = drvr_S7D1+2 ;slot 0, drive 2.drvr_S1D2 = drvr_S0D2+2 ;slot 1, drive 2.drvr_S2D2 = drvr_S1D2+2 ;slot 2, drive 2.drvr_S3D2 = drvr_S2D2+2 ;slot 3, drive 2.drvr_S4D2 = drvr_S3D2+2 ;slot 4, drive 2.drvr_S5D2 = drvr_S4D2+2 ;slot 5, drive 2.drvr_S6D2 = drvr_S5D2+2 ;slot 6, drive 2.drvr_S7D2 = drvr_S6D2+2 ;slot 7, drive 2.;LastUnit = drvr_S7D2+2 ;last device accessed by ProDOS.;ActDevCnt = LastUnit+1 ;count of active devices -1.ActDevLst = ActDevCnt+1 ;list of active devices.;; Each entry in the above list looks like:; DSSSiiii, where D =Drive, S =Slot, and i =; Identification.  Unfortunately, I don't know what the; identification nibbles are for each device.;SysCopyRgt = ActDevLst+14 ;the system (Apple) copyright notice.SysCallIRQ = SysCopyRgt+16 ;bank in RAM call IRQ ($FFD8).SysScratch1 = SysCallIRQ+6 ;temp scratch area.SysMemMap = SysScratch1+2 ;48k bitmap of RAM. (set means free).SysFileBuffs = SysMemMap+24 ;pointers to file buffers. (8).SysIntAddrs = SysFileBuffs+16 ;4 interrupt vectors.SysRegisters = SysIntAddrs+8 ;a,x,y,s,p register save area.SysWhatBank = SysRegisters+5 ;bank ID byte (RAM or ROM).SysIntReturn = SysWhatBank+1 ;interrupt return address.SysTheDate = SysIntReturn+2 ;the current date.SysTheTime = SysTheDate+2 ;the current time.SysFileLevel = SysTheTime+2 ;current file level.SysBkpBit = SysFileLevel+1 ;backup bit.SysScratch2 = SysBkpBit+1 ;unused scratch space.MachineID = SysScratch2+2 ;the machine ID byte.SysSlotROM = MachineID+1 ;a byte, each bit for card in slot x.SysPfxFlag = SysSlotROM+1 ;0 = no current prefix.SysMLIActive = SysPfxFlag+1 ;minus if so.SysLastReturn = SysMLIActive+1 ;last MLI call return address.SysMLI_X = SysLastReturn+1 ;save area for x-reg.SysMLI_Y = SysMLI_X+1 ;save area for y-reg.;; Some misc. routines follow.  Probably shouldn't document.;; spare routines: = SysMLI_Y+1 .. $BFFF.;; MachineID contains a single byte where:;; bits 7,6 and 2 are machine id number.; bits 5,4 are RAM configuration.; bit 1 is 80 column card flag.; bit 0 is clock card flag.;id_Machine = %11000100  ;mask for only looking at machine.id_Apple = %00000000 ;00xxx0xxid_ApplePlus = %01000000 ;01xxx0xxid_AppleIIe = %10000000 ;10xxx0xxid_AppleIII = %11000000 ;11xxx0xxid_AppleIIc = %10000100 ;10xxx100;ms_Memory = %00110000  ;mask for only looking at ram config.ms_48Kbytes = %00010000 ;xx01xxxxms_64Kbytes = %00100000 ;xx10xxxxms_128Kbytes = %00110000 ;xx11xxxx;dv_Device = %00000011  ;mask for only looking at devices.dv_80Columns = %00000010 ;xxxxxx1xdv_Clock = %00000001 ;xxxxxxx1;; We accept either; //e 128k, or //c, with or without a clock.;GoodID1  = %10110010 ;no clock. //e 128k.GoodID2  = %10110011 ;with clock. //e 128kGoodID3  = %10110110 ;no clock. //c 128k.GoodID4  = %10110111 ;with clock. //c 128k.;ThePathname = $301 ;from here to $382? is path stuff.PathLen  = ThePathnamePathStr  = PathLen+1;ThePrefix = ThePathname+64PrefixLen = ThePrefixPrefixName = PrefixLen+1;rm_PathComp = ThePrefix+64 ;hack completion string for filenames.TagSpace = rm_PathComp+64 ;temp space for tag search (Meta-.).;rm_FileBuffer = $A500   ;1 after last byte of AMACS.rm_DirectBuff = rm_FileBuffer  ;direct access disk buffer.rm_DataBuffer = rm_FileBuffer+$400 ;512 byte space.rm_ExcessComp = rm_FileBuffer+$200 ;a 1k region.rm_CompTable = rm_DataBuffer  ;space for completion pntrs.;; The total space used here is from rm_FileBuffer to; rm_DataBuffer+$200; which is $600 bytes.;; File type equates.;ft_NON = $00  ;no type.ft_TXT = $04ft_BIN = $06ft_DIR = $0F;