-*- Mode: Text -*-ReadMe________________________________________________________________________This file contains the help text for the Describe command in AMACS.  Eachentry should consist of text in the following form:Altmode<function-name>Altmode Altmode<text-body><cr>AltmodeFor example, to enter the "Foo Next Window" function, you type:Foo Next WindowMakes the next window be the one currently being "fooed".  Fix this functionby setting the variable Else Next Window Frob to Off.  Read the manual forbetter details.The <cr>Altmode is the delimiting sequence for the end of an entry, and mustnot appear elsewhere in the text.  The Alt-(function-name)-Alt-Alt should alsonot appear outside of a entry leader, as this can confuse the Describe reader.Please enter any stray Altmodes as Altmode characters, however, because ifthe file is printed by a graphics printer, or if AMACS is running in graphicsmode, the Altmode character may not echo as a dollar sign.  Feel free to editthis file, make corrections, etc.If you run out of room in this file, just make a new one, called"amacs.help2".  Up to 9 help files can be added in this fashion.Corrections that you do make should be sent to me, so that I can pass them onto other users.  You can reach me through U.S. Snail at:Brian Fox c/o CTI119 Hawthorne StreetChelsea, MA. 02150______________________________________________________________________________DiredDired enters a recursive editing level in a buffer with a directory listing init, where you can mark files for deletion, or select a file for editing.  Thefollowing DIRED commands are available:       N, Control-N:    Move down to the next file.       P, Control-P:    Move up to the previous file.       D, Delete:       Mark a file for later deletion.       U, Space:        Un-mark a file which you marked for deletion.       E:               DIRED Edit.  Edit a file, or DIRED directory.       V:               View contents of file.       Meta-P:          Edit previous directory.  DIRED's parent.       Q:               Exit DIRED, prompt for each marked file deletion.       ?, Control-_:    Display this text.Selecting another buffer, or killing the *DIRED* buffer causes an immediateexit from DIRED mode.  Only the "Q" command can eventually cause files to bedeleted.You can delete lines from the *DIRED* buffer, this simply means that thosefiles will never be looked at by DIRED, NOT that they will be deleted.DescribeM-X Describefoo<cr> prints out a verbose description of the function "Foo". The function's documentation must be looked up in a file first, so thiscommand may take a while to execute.  This text is being displayed by theDescribe command.  The text comes from the file "sys-path/help/amacs.help1". You can edit this file, and thus document your named kbd macros, or whatever.Forward CharacterForward Character moves Point forward over the next character.  Given anargument, it moves that many characters.  Given a negative argument, it movesbackwards instead.Backward CharacterBackward Character moves Point backwards over the previous character.  Givenan argument, it moves that many characters.  Given a negative argument, itmoves forwards instead.Down Real LineDown Real Line attempts to move Point to the same character column that it isin now, in the next line.  Given an argument, it moves that many lines. Given a negative argument, it moves up instead.Up Real LineUp Real Line attempts to move Point to the same character column that it isin now, in the previous line.  Given an argument, it moves that many lines. Given a negative argument, it moves down instead.Forward WordForward Word moves Point forward to the end of the current word.  If givenwhile Point isn't inside of a word, it moves to the end of the next word. Given an argument, it moves that many words.  Given a negative argument, itmoves backwards instead.Backward WordBackward Word moves Point backward to the start of the current word.  Ifgiven while Point isn't inside of a word, it moves to the start of theprevious word. Given an argument, it moves that many words.  Given a negativeargument, it moves forwards instead.Delete CharacterDelete character deletes the character just after Point, "pulling" all othercharacters after Point back one space.  Given an argument, it does that manychracters.  Given a negative argument, it rubs characters out instead.Backward Delete CharacterBackward Delete Character rubs out the character just before Point, "pulling"all of the text after Point back one space.  Given an argument, it does thatmany characters.  Given a negative argument, it deletes them instead.Backward Delete Hacking TabsBackward Delete Hacking Tabs acts exactly like Backward Delete Character,with one exception; when a Tab is encountered, it is first converted into thesame number of Spaces that the Tab was using.  Some people like to put thisfunction on the Delete key.Kill WordKill Word kills the next word, saving it into the kill ring.  Given anargument, it kills that many words.  Given a negative argument, it killsbackwards instead.Lowercase WordLowercase Word forces the next word to all lower case characters, movingPoint past the word.  Given an argument, it does that many words.  Given anegative argument, it lowercases that many words before Point, but leavesPoint where it is.  This makes it easy to correct your typing.Uppercase WordUppercase Word forces the next word to all upper case characters, movingPoint past the word.  Given an argument, it does that many words.  Given anegative argument, it uppercases that many words before Point, but leavesPoint where it is.  This makes it easy to correct your typing.Uppercase InitialUppercase Initial capitalizes the next word, moving Point past the word.Given an argument, it does that many words.  Given a negative argument, itcapitalizes that many words before Point, but leaves Point where it is.What LossageWhat Lossage displays the last 60 characters that you have typed, in thehope that this will give you enough information to figure out what horriblekind of thing you have just typed, and what the right thing is to do to fixit.List DirectoryList Directory types out a listing of all files in the current directory.  Itdisplays the size, type, and name of each file in the directory.List FilesList Files types out a listing of the filenames that start with the argumentthat you pass.  If no argument is passed, all files are displayed.Invert Mode LineInvert Mode Line toggles the state of the Modeline display.  Some people likethe Modeline to be displayed in reverse video, some don't.Not ModifiedNot Modified makes AMACS think that the buffer hasn't changed since it'sincepton.  You might want AMACS to think this so you can't save any changesyou made accidentally, or because you want to know if you change the bufferfrom here on in.Set Pop MarkSet Pop Mark pushes the value of Point onto the mark stack.  Given anargument, it pops Point from the mark stack instead.  Setting the mark is animportant thing to do; it allows you to define regions.  The region is thearea between Point and Mark.What KeyWhat key waits for you to type a key, and then tells you what that key does.Open Blank LineOpen Blank Line inserts a carriage return into the text, but Point staysbefore it.  Given an argument, it creates that many blank lines after Point.Open Blank Line is a good way to "make some space", and the blank spaceusually helps you to concentrate on what you are writing.CRLFCRLF inserts a carriage return into the buffer at Point, and then moves Pointpast it.  This is almost like Self Insert, but CRLF knows how to "use up"blank lines, instead of just inserting.  Also, CRLF is much faster than SelfInsert when it comes to redisplay.Set KeySet Key connects a keystroke to a function.  The function is always promptedfor; without a numeric argument, the keystroke is as well.  Given a numericargument, the value of the argument is used as the internal AMACS charactercode for the keystroke.  The only 2 keys which you need to set this way areAltmode (code 155), and Control-G (code number 135).  All other keystrokescan be typed directly to Set Key.Kill LineKill Line kills the line at Point, from Point upto the end of the line. If Point is on a blank line, (or one which looks blank), then Kill Line justkills the carriage return at the end of the line.  If there is text on theline after Point, then it kills the text upto (but not including) thecarriage return. Given an argument, Kill Line kills that many lines, andthe carriage returns as well.  Given a negative argument, it kills that manylines backwards.Prefix MetaThe key that runs this function turns on the Meta bit in the next characterthat you type.  The usual key that is connected to this function is Altmode(the ESC key on the Apple).  Thus, typing Altmode F is equivalent to thesingle character Meta-F, which is useful if your keyboard has no Meta key. If you have an Apple //e, or //c, the Meta key is defined as either one ofthe Apple keys.Prefix Ctrl-MetaThe key that runs this function turns on both the Control and Meta bits inthe next character that you type.  The usual key that is connected to thisfunction is Control-Z.  Typing Control-Z, Control-Z (for Control-Meta-Z), iseasier for some people, so this function has been provided.Quoted InsertQuoted Insert inserts the next character that you type.  This is a way ofinserting control characters into your text.Extended CommandThis function is the way you invoke a function which is not connected to akey.  You type: M-X foo<CR> to invoke the function named Foo.  If the Foofunction does something with numeric arguments, just give the numericargument to M-X, as in C-U 3 M-X foo<CR>.  If the function does somethingwith string arguments, you will be prompted for the string when the functionis run.  Optionally, you may supply string arguments after the function name,separated with Altmodes as in M-X foobar<CR>, which invokes the functionFoo, with the argument of "bar".  Completion happens on the function name asyou type it; you need only type the unique portion of the function name.  Formore information, see your AMACS User's Manual.Instant Extended CommandThis function is just like Extended Command (q.v.), except that the functionyou invoke will ALWAYS prompt for it's arguments.  This is provided mostlyfor historical reasons, if you don't supply arguments to M-X, the invokedfunction will prompt you anyway.Insert FileInsert File inserts the contents of a specific file into the buffer at thelocation of Point. The filename may be typed after the command name, as in:M-X Insert Filefoo<CR>If no filename is specified as an argument, Insert File prompts you for one.Type the name of the file that you wish to insert, or C-G to abort.If Insert File cannot find the file on the disk, it prints a message to thateffect.  If any errors occur during the reading of the file, Insert File willalso notify you of that fact.  Insert File doesn't change the name of thecurrently visited file,  you must use Visit File to do that.Visit FileVisit File reads a file from the disk into the currently selected buffer,making the file read the buffers "visited file".  If the file that was beingvisited in the buffer contains changes, an offer to save the file first isgiven.  The filename can contain location information; in the DOS 3.3 versionof AMACS, the location information looks like:filename,S6,D2,V9In the ProDOS version, the pathname may be included.  If this information isleft out,  AMACS will supply it for you.  Thus, files with similar names, butdifferent locations, may be read into different buffers, and AMACS will beable to save them to the right place.Visit File with the name of a file that doesn't exist just sets the buffer'svisited filename to the one specified, and prints "(New File)" in the echoarea.Write FileWrite File prompts you for a file to write to, and then saves the currentbuffer's contents under that name.  Since the contents of the buffer and thecontents of the file that you just wrote to are the same, it sets the buffer'svisited filename as well.AproposApropos types out useful information on functions, based on a substring whichyou supply.  The substring is searched for in all of the function names, anddocumentation strings that AMACS currently knows about.  The standard methodof supplying arguments is supported; i.e. M-X Aproposfoo<CR> is equivalentto typing M-X Apropos<CR>foo.  In the former case, no prompting is given, inthe latter, you are prompted for a function name.  Apropos takes multiplearguments, given them, it does an Apropos for each one.  Thus, if you areinterested in killing, or deleting, you could type: M-X Aproposkilldel<CR>.New WindowNew Window puts Point on a specific line of the screen, dragging the textaround Point with it.  With no argument, it centers the line that Point is inaround the line in the variable "Cursor Centering Line".  Given a numericargument, it centers around the line that many lines from the top of thewindow.  Given a negative argument, it centers around the line that manylines from the bottom of the window.  New Window with just an argument of C-Uis different; it redisplays only the line that Point is in.Next ScreenNext Screen scrolls the text in the window towards the top of the window,showing you more lines at the bottom.  With no argument, it takes "Next ScreenContext Lines" lines from the bottom of the window, and places them at thetop.  Given an argument, it scrolls that many lines instead. Given a negativeargument, it scrolls the lines down, away from the top of the window.Previous ScreenPrevious Screen scrolls the text in the window towards the bottom of thewindow, showing you more lines at the top.  With no argument, it takes "NextScreen Context Lines" lines from the top of the window, and places them atthe bottom.  Given an argument, it scrolls that many lines instead. Given anegative argument, it scrolls the lines up, away from the bottom of thewindow.Move To Screen EdgeMove To Screen Edge moves Point in relation to the text in the window; noneof the text in the window is changed, just the postion of Point.  With noargument, it places Point at the leftmost character of the current line,given an argument, it places Point at the leftmost character of that line. Negative arguments count back from the bottom of the window.Self InsertSelf Insert inserts the character which invoked it.  Given an argument, itinserts that many copies of the character.  Negative arguments are treated astheir absolute value.  C-G aborts insertion, in the case of an accidentallarge argument.Tab InsertTab Insert simply inserts a Tab character at point.SpaceBarSpaceBar simply inserts a Space into the text at Point, unless Auto Fill Modeis turned on.  In that case, it wraps the line that Point is in to FillColumn, if that is neccessary.Universal ArgumentUniversal Argument multiplies the current argument value by 4.  SuccessiveC-U's multiply by 4 as well, while typing digits replace the argument value,and start a new argument.  You can type digits, and multiply them withUniversal Argument, as in M-9 C-U, which would give you an argument of 36. For commands that only care whether or not there is any argument, and not thevalue, C-U is a good way of saying that you want one.  Many commands use anargument as a repeat count, here are a couple of good combinations:C-U C-U C-N	will move Point down 16 lines, which is about 3/4 of the		window height on the Apple.C-U C-U C-F	moves Point forward 16 characters, which is about a quarter		of a line on the Apple.C-U 0 C-L	moves Point, and the line that it is in, to the top of the		window, so that you can see more text below, without losing		your typing position.Negative ArgumentNegative Argument starts a negative argument for the next command that youtype.  Successive digits are processed in the same fashion that UniversalArgument (q.v.) does after a minus sign.Argument DigitArgument Digit adds the digit value of the digit that you have typed to thecurrent argument.  For example, C-U calls Argument Digit with any digitcharacters that you type after the C-U.  Meta digits call this explicitly.Transpose CharactersTranspose Characters swaps the position of the characters around Point.  IfPoint is at the end of a line, it swaps the characters before Point,otherwise, it swaps the character after Point with the character beforePoint.  This means if you type "thier", and you place Point on the "e",Transpose Characters will do the right thing.  The variable "TransposePrevious Only", if on, makes Transpose Characters always act as if it were atthe end of a line.Transpose LinesTranspose Lines exchanges the entire line that Point is in with the lineabove it.  This is roughly equivalent to typing C-K C-K C-P C-Y, but itdoesn't matter where Point is in the line.Accumulate Matching LinesM-X Accumulate Matching Linesfoo<CR> gathers all of the lines which contain"foo" after Point into the kill buffer.  Given a negative argument, itdeletes the lines as well.  This is exceptionally useful for creating ".h"files for C programs, or a table of contents for a manual.  You might typeM-X Accumulate Matching Lines[Section<CR>, and then Un-Kill them intoanother buffer.Beginning of LineBeginning of Line moves Point to the beginning of the line that it is in. Arguments are ignored.End of LineEnd of Line moves Point to the end of the line that it is in.  Arguments areignored.Goto BeginningGoto Beginning places Point at the top of the buffer.  If more than "AutoPush Point" characters are moved over, the previous value of Point is pushedonto the Mark stack.Goto EndGoto End places Point at the end of the buffer.  If more than "Auto PushPoint" characters are moved over, the previous value of Point is pushed ontothe Mark stack.Incremental SearchIncremental Search interactively searches for a string as you type it in.  If"Case Search" is on, upper and lower case characters are different, otherwisethey are treated as matches. Called with a negative argument, it searchesbackwards instead.  Control-S reads characters, and positions the cursor atthe first occurrence of the characters that you have typed.  When you aresatisfied with the place that you have reached, you can type an Altmode,which stops searching, leaving the cursor where the search brought it.  Also,any command not specially meaningful in searching stops the searching, and isthen executed.  Thus, typing C-A will exit the search, and then move to thebeginning of the line.  Here is a list of characters which are special withinIncremental Search:Control-S	Search again for the last string which was succesfully		searched for.  If you search for "foo", and find it, but		not the one that you were searching for, type Control-S.		The next occurrence of "foo" will be searched for.Delete		Rubs out the last search.  If you type the wrong character by		mistake, Delete removes it from the prompt line in the echo		area, and moves the cursor back to the last successful search.		Typing Delete to an empty search string exits the search.Altmode		Exits the search without doing anything else.  If you type		Altmode to an empty search string, it runs the function		String Search instead. (q.v.)Control-R	Like Control-S, but searches backwards instead.Control-Q	Quotes the next character that you type.  This is a way to let		you search for Control-Q's for example.Control-G	Stops searching.  In the middle of a search, simply stops		searching, and leaves you at the point that you started from.		Typed to a failing search, discards all previous searches that		have failed.  Typed to a successful search, stops Incremental		Search, and leaves Point where the initial search started from.Reverse Incremental SearchSee Incremental Search.  It calls that with a negative argument.String SearchSearches for a string that you type.  The search begins when you type an Altmode.  If "Case Search" is on, upper and lower case characters aredifferent, otherwise they are treated as matches.  Control-S typed to anempty search string, types the search string default for you.  Control-Qquotes the next character that you type.  Control-G aborts the function.    Control-B does a BJ Search;	jump to beginning, and then search.     Control-E does an EJ Search;	jump to end, and then search backwards.     Control-R does Reverse Search.Reverse String SearchSee String Search.  It calls that with a negative argument.Replace StringReplace String replaces occurences of a string with another string, afterPoint in the buffer.  The percentage display at the far right of the modelinereflects the state of the search for the string that you want to replace.  If"Case Search" is on, upper and lower case characters are different, otherwisethey are treated as matches.  If "Case Replace" is on, case information isnot preserved during replacement.  For example, to replace "foo" with "bar",you would type: "M-X Replace Stringfoobar<cr>".  This would cause "foo"'sto become "bar"'s, "FOO"'s to become "BAR"'s, and "Foo"'s to become "Bar"'s. The following characters have special meaning in the search string:Control-W		Matches any whitespace character. (Tab or Space)Control-X		Matches any single character.Control-O		Means "or" in the search.  For example, you might want			to replace all "foo"'s or "bar"'s with "baz".  You			type "M-X Replace Stringfoobarbaz<cr>", and it			does the right thing.Control-Q		Quotes the next character in the search string.  This			allows you to search for Control-X's, for example.Control-N		When followed by a character, says that that character			may NOT appear in the string.  I.E., if you wanted to			change "bar" and "baz" to "foo", but you didn't want			occurences of "barn" to be changed, you could use:			"bar^Nn" as the search string.Query ReplaceQuery Replace is just like Replace String (q.v.), except it asks you forconfirmation before each replacement is made.  Control-G aborts, "Y" acceptsthe replacement, "N" says not to replace this one, and "!" means replace thisoccurrence, and stop asking me.Top Level AbortRings the bell, and stops whatever happens to be going on.  Control-G alwaysstops things, except when it doesn't.  Please report those cases.List VariablesList Variables types out a list of the variables whose names or documentationcontain a substring which you specify.  The values of the variables listedare also displayed.Outdent LineOutdent Line gives the current line the same indentation as the previouslyoutdented line in the buffer.  This is primarily useful for block structuredprogramming languages, such as Pascal, or C.  See also Outdent CRLF.Outdent CRLFOutdent CRLF calls CRLF (q.v.) and then calls Outdent Line.  This has theeffect of indenting the new line under the previously outdented line in thebuffer.  If you are Pascal Mode, by default this function is mapped toMeta-Return.Set VariableSet Variable allows you to customize AMACS to some extent.  If the variableyou wish to set is numeric, or a flag (i.e. On or Off), then you may specifythe value with a numeric argument to Set Variable.  AMACS has quite a fewvariables which control the way the terminal acts, and the actions of somefunctions.  Sorry EMACS people, we don't have local variables.  See yourAMACS manual for more details.MerlinizeMerlinize assumes the buffer contains an assembly langauge program for theApple assembler Merlin, and converts it to a form which makes it parseable bythat assembler.  See the manual for specifics.  Suffice to say that you cantype in a source file the way you like to see it, and Merlinize will fixthings up so that Merlin can read the file.UnMerlinizeUnMerlinize assumes the buffer contains an assembly language program in theformat that the Apple assembler Merlin uses, and converts it to a form whichis readable by human beings.  See the Manual for specifics.  Suffice to saythat you can read in a file written with that assembler, and UnMerlinize willmake it into something that you can read.  See also Merlinize.Delete Blank LinesDelete Blank Lines removes the contiguous blank lines (lines containing onlyTabs or Spaces) at Point, leaving one blank line.  Given on a non-blank line,it removes all whitespace from the end of that line.Delete Horizontal SpaceDelete Horizontal Space removes all Space and Tab characters around Point. This doesn't kill the space, it deletes it instead.Save FileSave File writes the file that is being visited by this buffer into thevisited filename making your changes permanent.  If the file is a new file,then "Default File Type" controls the type of file that is written; 4 fortext-type, and 6 for binary.  The default value for Default File Type is 4.Atom Word ModeAtom Word Mode makes all of the word commands ignore the standard delimitercharacters; "-" (hyphen), and "_" (underscore).  This is primarily usefulwhen editing programs, some people like names like "com-atom-word-mode", andsome people don't.  This minor mode is not dependent on any major mode.Auto Fill ModeAuto Fill Mode makes Space break lines which would pass the value of "FillColumn".  You can set the value of Fill Column with Control-X F; this setsFill Column to the column that Point is in, or with a numeric argument, tothat column instead.  See section 9.7 [Filling Text] for more information onhow text is filled.Back to IndentationBack to Indentation moves point to the first non-whitespace character in thecurrent line.  By default, this function is found on Meta-Tab, not Meta-M asin EMACS.Exchange Point and MarkMakes Mark have the value of Point, and Point have the value of Mark.  Eachbuffer has it's own stack of marks, the text between Point and the currentMark is called the "region", and can be manipulated by the functions whichhave the word "region" somewhere in their names.Count OccurrencesCount Occurrences prints the number of times a certain string appears pastthe current location of Point.  Each line may only contain one occurence,other occurences on the same line are ignored.List Matching LinesTypes out the lines which contain a certain string past Point.  Given anargument, that many lines around the occurence are printed.  Try It.BccurTypes out the lines which contain a certain string in the buffer.  Given anargument, that many lines around the occurence are printed.  Try It.Do Last Kbd MacroDo Last Kbd Macro executes the definition of the most recently definedkeyboard macro.  For more information on keyboard macros, see the AMACS UserManual.Select BufferSelect Buffer switches between buffers.  Given the name of a buffer whichalready exists, it selects that buffer.  Given the name of a non-existantbuffer, it creates one instead.  AMACS allows a maximum of 14 buffers to becreated in any one editing session.Rename BufferRename Buffer changes the name of the buffer that you are currently using. You must supply the argument after you type the function name, no promptingwill be given.  The visited filename doesn't change, this is just forrenaming the current buffer.List BuffersList Buffers types out a list of the currently active buffers.  A typicallist might look like:    Main			/profile/some.file		 800. * Foo				/hard1/another.file		13643k in use by 2 buffers, 42k remaining.The first two columns reflect the state of the buffer; a dot in the firstcolumn indicates that this is the buffer you are currently editing in, anasterisk (*) in the second column indicates that the buffer has beenmodified.  The name of the buffer follows, then the file that the buffer isvisiting, if any, and the size of the buffer's contents in bytes.  Finally, astatus line, telling you how much buffer space is used, and how much isremaining is printed.View Kbd MacroDisplays the contents of the Kbd macro array, or given a numeric argument,just that macro.  The contents are pretty-printed on the typeout window. There isn't any good way to edit Kbd macros right now, this is being fixed.HelpHelp gives you help in one of many various ways.  Type "?" after invokingthis function to see what the options are, and what they do.  There is noINFO option.Find FileFind File visits a file in its own buffer.  If AMACS has a buffer that iscurrently visiting the filename that you specify, that buffer is simplyselected.  Otherwise, a buffer is created, and the file is visited in thatbuffer.  Find File is a good way to get at the file you want to edit becauseyou don't have to remember whether the file is already visited or not.  IfFind File creates a new buffer for the file, the name of the buffer is thefilename that you specify, without the pathname information, while thevisited filename is preserved with the pathname information.Two WindowsTwo Windows creates two windows on the screen, and leaves you editing in thebottom one.  The top window always contains the buffer that you are editingin, the bottom window may contain the same buffer, or a different one.  Ifthis is your first entry to two-window mode, a new buffer is created, called"W2".  Otherwise, the bottom window contains the same buffer that it had whenyou last exited two-window mode.One WindowOne Window grows the window that you are editing in, so that it uses thewhole screen.  If you are in the bottom window when you type C-X 1, thebottom window's buffer will be the buffer that takes the entire screen,otherwise the top window's buffer will use the entire screen.  You can useOther Window to edit the buffer that was in the other window.Other WindowIf you are editing in two-window mode (see Two Windows), Other Window movesthe cursor into the other window, and begins editing there.  If you have usedTwo Windows before, Other Window selects the buffer that was in the otherwindow.  Otherwise, Other Window just beeps.Grow WindowGrow Window makes the current window that you are editing in larger orsmaller.  Given a positive argument, it makes the window that you are inlarger, by that many lines; given a negative argument, it makes the windowsmaller.  Window sizes are remembered, even if you leave two-window mode, andthen re-enter it later.Lowercase RegionLowercase Region converts all of the characters between Point and Mark tolowercase.Uppercase RegionUppercase Region converts all of the characters between Point and Mark touppercase.Capitalize RegionCapitalize Region converts each word between Point and Mark to a capitalizedword, i.e. the first letter of the word to uppercase, all subsequent lettersto lowercase.Kill RegionKill Region kills the text between Point and Mark, placing it into the killring.  You can get back killed text by using Un-Kill (C-Y); you can appendto the already killed text by using Append Next Kill(C-M-W).Copy RegionCopy Region copies the text between Point and Mark into the kill ring, justas if it had been killed, but doesn't actually remove the text from thebuffer.Count Lines RegionCount Lines Region adds up the total number of Carriage Return characters inthe text between Point and Mark.  This is a reasonable way to find out howmany printed pages of text you have in the region.Backward Kill WordBackward Kill Word kills the previous word, saving it into the kill ring. Given an argument, it kills that many words.  Given a negative argument, itkills forwards instead.Backward Kill LineBackward Kill Line kills the line at Point, from Point back to the start ofthe line.  If there is text on the line before Point, then it kills the textback to (but not including) the carriage return. Given an argument, BackwardKill Line kills that many lines, and the carriage returns as well.  Given anegative argument, it kills that many lines forwards.Indent RegionIndent Region indents each line in between point and mark, adding thearguments indentation to each line.  Given a negative argument, it outdentseach line instead.  The region will change after the indentation is performed,so the point and mark are left at the same place.Indent for CommentIndent for Comment moves to the start of a comment on the current line,indenting the comment to the column in Comment Column.  If no comment ispresent, it creates one by inserting the values of Comment Begin, and CommentEnd, and leaving point in between them.  Just type Meta-; anywhere within aline, and you will be ready to type the comment.Up Comment LineUp Comment Line first removes any blank comment from the current line, thenmoves up one line, and calls Indent for Comment (q.v).Down Comment LineDown Comment Line first removes any blank comment from the current line, thenmoves down one line, and calls Indent for Comment (q.v).What Cursor PosWhat Cursor Pos prints information about point that is easy and quick tocompute.  A typical information line looks like:     X =0, Y=16,  CH =141  Point is at 31200 of 31791X is the current horizontal position of the cursor.  Y is the current verticalline of the cursor.  CH is the internal character code (in decimal) of thecharacter that is under the cursor.Label SearchLabel Search reads a string from you in the echo area terminated by a return,and then searches for that string starting in column 0.  To put this anotherway, it will only find the string that you type if that string is directlypreceded by a carriage return.  The search starts from the beginning of the buffer.Kill CommentKill Comment removes any comment that may been on the current line, bydeleting any whitespace before the comment, and then calling Kill Line.  Thecomment starter is killed right along with the text in the comment.Set Comment ColumnSet Comment Column sets the value of the variable Comment Column to the columnthat point is in.  Given an argument, it sets the value of Comment Column tothat value.Lisp ModeLisp Mode sets things up for editing Lisp code.  Right now this means that thecomment variables are set to the defaults for Lisp; i.e. ";" for CommentStart, and "" for Comment End.C ModeC Mode sets things up for editing C code.  Auto Indent mode is turned on, andthe comment start, and end are set to "/*" and "*/" respectively.Merlin ModeMerlin Mode sets things up for editing assembler code.  Meta-M is bound to thefunction UnMerlinize, Meta-Return is bound to the function Merlinize, andComment Start and Comment End are set to ";" and "" respectively.Text ModeText Mode sets things up for editing English text.  Auto Fill mode is turnedon, and there are no defined comments.Pascal ModePascal Mode sets things up for editing Pascal code.  Auto Indent mode isturned on, and Comment Start, and Comment End are set to "{" and "}"respectively.  In addition, Outdent CRLF (q.v) is mapped to Meta-Return.Fundamental ModeFundamental Mode is the mode in which AMACS starts out.  ReenteringFundamental Mode doesn't change anything else that you may have set in someother buffer.  Fundamental Mode isn't very interesting, but it is the defaultediting environment.Debug FunctionDebug Function prints the hexadecimal address of the function whose name youspecify.  This only helps you if you have a source code license for AMACS.  Ifyou do, it can help you to debug your not-quite-working function.What Available SpaceWhat Available Space prints the amount of available buffer space in AMACS inpages.  The term "page" refers to a disk page; this is a 512 character blockof text.  You can use this command to see if a file on disk will fit into abuffer, or if there is enough room on disk to save a buffer.Kill BufferKill Buffer removes a buffer from AMACS, so that more buffer space isavailable.  You are prompted for the buffer name, typing <CR> at the promptkills the current buffer.  This works great if you use Find File a lot.Fill RegionFill Region fills each line between point and mark to the column specified inFill Column.  See the manual for details on how text is filled.Hardcopy RegionHardcopy Region sends the text between point and mark to the printer specifiedin HC Slot.  Many variables affect the appearence of the text, see Chapter 19,Hardcopy for details on how text is printed.Hardcopy BufferHardcopy Buffer sends the text in the buffer to the printer specified in HCSlot.  Many variables affect the appearence of the text, see Chapter 19,Hardcopy for details on how text is printed.Append Next KillAppend Next Kill makes AMACS think that the last command issued was a killcommand.  This means that the next command (if it is a kill) will append, orprepend the killed text to the text already in the kill ring.  This is amethod for gathering discontiguous text into a single group.Un-KillUn-Kill inserts the contents of the kill ring into the current buffer atpoint, leaving point just after the re-inserted text, and mark just before it.You can Un-Kill the same text more than once, succesive C-Y's continue to"yank" back the contents of the kill ring.Set Goal ColumnSet Goal Column sets the value of the variable Goal Column to the columnthat point is in.  Given an argument, it sets the value of Goal Column tothat value.  If Goal Column is non-zero, Up Real Line, and Down Real Line tryto place point in that column, otherwise, they tend to move vertically.Start Kbd MacroStart Kbd Macro begins the definition of a keyboard macro.  The modelinedisplays "Def" and as you type subsequent commands they are remembered as wellas executed.  You end the definition by typing C-X ).  You re-execute thedefinition with the C-X E command (Do Last Kbd Macro).End Kbd MacroEnd Kbd Macro ends the definition of a keyboard macro.  You should onlyexecute this command by typing C-X ), as the method of determining exactlywhat makes a keyboard macro is somewhat crufty.  Type C-X E (Do Last KbdMacro) to re-execute the defintiion.Backward ParagraphBackward Paragraph moves point back to the previous paragraph.  Given anargument, it moves over that many paragraphs.  Negative arguments moveforwards.Forward ParagraphForward Paragraph moves point forward to the next paragraph.  Given anargument, it moves over that many paragraphs.  Negative arguments movebackwards.Fill ParagraphFill Paragraph fills each line in the paragraph that point is in (or the nextparagraph if point is between them).  The text is filled to the column in FillColumn, and point is left at the top of the paragraph, with mark at thebottom.Goto Next LabelGoto Next Label moves point to just after the next "label" in the buffer. Given an argument, it skips that many labels; negative arguments movebackwards.  A label in AMACS always starts in column 0; see section 16.9[Function Fiddling] in the manual for more details.Goto Previous LabelGoto Previous Label moves point to just before the previous "label" in thebuffer.  Given an argument, it skips that many labels; negative arguments moveforwards.  A label in AMACS always starts in column 0; see section 16.9[Function Fiddling] in the manual for more details.Reposition WindowReposition Window tries hard to get as much of the function that you areediting on the screen.  It does this by setting the mark at the previouslabel, and then trying to put that label at the top of the screen, withoutletting point leave the screen.  If it fails, you can always use C-X C-X(Exchange Point and Mark) to move to the function beginning.Forward SentenceForward Sentence moves to just after the end of the sentence that you are in,or to the end of the next sentence if you are between sentences.  AMACSthinks that a sentence ends when a period, question mark, or exclamation markis found.  Arguments move over that many sentences, negative arguments movebackwards.Backward SentenceBackward Sentence moves to the start of the sentence that you are in, or tothe start of the previous sentence if you are between sentences.  AMACSthinks that a sentence begins when a sentence end is found, and then movesforward to the first non-whitespace character.  Arguments move over that manysentences, negative arguments move forwards.Kill SentenceKill Sentence kills from point to the end of the current sentence, or to theend of the next sentence if point is between them.  Arguments kill that manysentences, negative arguments kill backwards instead.Backward Kill SentenceBackward Kill Sentence kills from point to the start of the current sentence,or to the start of the previous sentence if point is between them.  Argumentskill that many sentences, negative arguments kill forwards instead.Mark BufferMark Buffer places point at the top of the current buffer, and mark at theend.  Then, you can use any of the region commands to act upon the entirebuffer.  In order to find out how many lines are in the buffer, you can type:C-X H, M-=, for example.Mark ParagraphMark Paragraph places point at the top of the current paragraph (or nextparagraph if between them), and mark at the end.  You can then use any of theregion commands to act upon the paragraph.Auto Indent ModeAuto Indent Mode makes CRLF (q.v) indent to the same column that the text onthe previous line is indented to.  Pascal and C modes turn this on bydefault.  You may want to put Backward Delete Hacking Tabs on the Delete keywhen this minor mode is on.  To turn it off, just type another M-X AutoIndent Mode, it toggles.Caps Word ModeCaps Word Mode makes the word commands recognize a case change in letters asan appropriate place for a word delimiter.  It doesn't remove any of theother word delimiters that are in effect.  Caps Word Mode is most useful whenyour program contains labels such as:void MakeNewPointerVariable() {....}Set PrefixM-X Set Prefix/profile<cr> sets the current default prefix to "/profile",while M-X Set Prefix<cr> displays the current default prefix.  The defaultprefix is that portion of a filename which describes where to find a specificfile.OnlineM-X Online examines all of the disk devices attached to your computer, andprints the volume names, slot and drive, of any mounted volumes that itfinds.Delete FileM-X Delete Filefoo<cr> deletes the file "foo" from disk, making it go awayforever.  You may want to do this to some uninteresting files if you findthat you need more space on the disk to save the current file that you areworking wih.CompileM-X Compile invokes the system file specified in the variable CompilerFilename.  It first asks you if you want to save any modified buffers.  Sincethere is no convention with the Apple for the method in which compilersoperate, it is diffilcult to pass the name of a specific file to thecompiler.  The convention the we use is to place the current buffer'sfilename into the Input Buffer ($200), and terminate it with a <cr>.Kill LineKill Line kills from point to the end of the line, placing the text that itkills into the kill ring.  Given on a blank line, it removes that lineinstead.  Given with an argument, it kills that many lines, and the lineseparators that follow them.ExitM-X Exit exits AMACS, and gives you a chance to select another applicationwhich you wish to run.  M-X ExitFoo<cr> tries hard to start up theapplication named "FOO" directly.  This may not always be possible, for somefiles it works, and for others it doesn't.  Giving a numeric argument to Exitcauses AMACS to save the current buffer state in a file called AMACS.BUFFERS.If this file is present when AMACS is started up, it is loaded, thusreturning you to your editing session, uninterrupted.Edit Tab StopsM-X Edit Tab Stops places you into a recursive editing level where you canedit the definition of the tab stop table for the current major mode.  Thetable is a line of 80 characters which determines how tab characters aredisplayed.  The variable Use Tabs Table, if On, allows the display ofvariable length tabs.  Otherwise, tab stops are every 8 columns.  Thecharacter commands for editing the tab table are:    Tab      advance to the next defined tab stop.    Space    clear current tab stop.    C-F      move forward.    C-B      move backward.    Delete   clear the previous tab.    Altmode  exit Edit Tab Stops, and accept the changes.    C-G      abort Edit Tab Stops, throw away any changes to the table.Edit DefinitionMoves directly to the function which you specify, as long as the function canbe found in the "tag-table".  If there is no buffer named *TAGS*, EditDefinition complains.  If the function can't be found, Edit Definition tellsyou about that too.  Given an argument, Edit Definition moves to the nextfunction in the tag-table which begins with the partial string you have typed.What Tag FileCalls a special version of Edit Definition (M-.) which doesn't move you to thefunction.  Instead, it prints the name of the file which would have been movedto in order to place you at that function.  Takes arguments just like EditDefinition (q.v.).Visit Tag TableCreates or finds a buffer named *TAGS*, and then calls Visit File with thename of the file that you specified, verbatim.  This is the recommended way toget a tag-table into AMACS, although you can just as well manually manufacturethe buffer yourself.Load LibraryM-X Load LibraryFoo<cr> loads the library named Foo, and tries to run thefunction "& Init Foo".  The library is looked for in the directory:"sys-path/LIB".  Control-Meta-L can be used to flush all of the activelibraries.  You might want to do this if the library facility isn't able toload a library because of lack of space.