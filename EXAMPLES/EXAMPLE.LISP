;;; -*- Mode: Lisp -*-|#    This file contains some example Lisp functions that you can twiddle with.    Since there is no Lisp interpreter currently available for the Apple,    (you just have to be a little patient!) there isn't much else that you    can do with the text.  A Lisp environment for the Apple //gs is in the    planning stages right now, from CTI.#|;;; The following function is good for looking at paren matching.  Sit next to;;; an open or close parenthesis, and the matching parenthesis blinks.(defun fact (x)			;return factorial of arg.  (cond ((lessp x 2) 1)	(t (times x (fact (minus x 1))))));;; The following code is taken from the Lisp Machine Window System Manual. ;;; It is simply reasonably hard code to format, so I thought that I would;;; include it here.  Place the cursor somewhere within the function, and;;; type C-M-R (Reposition Window).|#	Delaying Redisplay After TypeoutThe typeout window superior must know how to check before redisplaying to findout whether part of its last display has been overwritten by the typeoutwindow and therefore must be redisplayed.  To find out how much screen heightthe typeout window has used, use the :bottom-reached operation on it.  Thetypeout window must also be deactivated so that more typeout, happening afterthe redisplay, will work properly.Here is an example which is how general scroll windows do this:#|(defmethod (tv:scroll-window-with-typeout-mixin :before :redisplay)	      (&rest ignore)   (when (funcall tv:typeout-window ':active-p)     (let ((br (min tv:screen-lines      	            (1+ (truncate (send tv:typeout-window ':bottom-reached)		     	      	  tv:line-height)))))       ;; br is the number of lines of the display that       ;; were clobbered by typeout actions.       (funcall tv:typeout-window ':deactivate)       (dotimes (l br)				;Mark lines as clobbered.	 (aset nil tv:screen-image l 0)	 (aset  -1 tv:screen-image l 1)	 (aset  -1 tv:screen-image l 2))       ;;Erase the clobbered area.       (send self ':draw-rectangle       	     (tv:sheet-inside-width)	     (* br tv:line-height)	     0 0	     tv:alu-andca))))|#The editor normally updates its display after each command.  But after acommand that prints typeout, it is important not to update the permanentdisplay right away, because that would make the typeout disappear almost assoon as it appeared.  The same consideration applies to other programs thatuse typeout windows.The convention in this situation is that after a command that has producedtypeout, redisplay should be delayed until the user types another inputcharacter.  If that character is a space, it is discarded.  Otherwise, it isinterpreted as a command.The way the program should decide whether to wait for redisplaying is toinvoke the :incomplete-p operation on the typeout window.  This reads a flagthat is set whenever output is done the typeout window and can be cleared bythe program's command loop between commands.  Thus, the flag indicates whetherthe typeout window was used during the last command.Here is a sample piece of code that illustrates this technique:#|(let ((standard-output typeout-window))  (do-forever				; Clear the flag.    (send standard-output ':make-complete);;; Read and execute one command.    (process-command (send standard-input ':tyi))    (when (send standard-output ':incomplete-p)      ;; If this command printed some typeout, delay redisplay       ;; by waiting for the next input character to be typed.      (let ((ch (send standard-input ':tyi)))        (unless (eq ch #\sp)	  ;; Anything else but space, execute as a command.	  ;; Since space is not un-tyi'd it allows immediate redisplay.	  (send standard-input ':untyi ch))))  ;; Here is where we redisplay after each command.  (unless (send standard-input ':listen)    ;; Normal redisplay deactivates (initializes) the typeout window.    (redisplay-normal-redisplay))))