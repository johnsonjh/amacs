;-*- Mode: Merlin -*-;;File    :SI:SCROLLING;Author  :Brian Fox;Address :119 Hawthorne Street;         Chelsea, MA. 02150;Phone   :(617) 884-5454;; README:;;    If you are reading this file because you are a new user of;    AMACS, then this text is for you.  Merlin doesn't like;    tab characters.  People do, myself included.  In order to;    transform this file into an assembleable format, use the;    M-Return command (Merlinize).  Hold down one of the Apple;    keys while typing the Return key.  This transforms the;    file into something that Merlin likes.  If you want the;    file to look like people like,  type M-M (UnMerlinize). ;    This makes the file person readable (but not neccessarily;    personable).;; This file is the sole property of Brian Fox, and; his associated company, Creative Thinking, INC.;; This file may not be reproduced in any way or; fashion, without the explicit written permission; of Brian Fox.;; This file contains valuable trade secrets used by; Creative Thinking, INC., in the production and; manufacture of its products, and as such is protected; under the copyright laws of this state.;; Copyright 1985, Brian Fox; Copyright 1985, Creative Thinking, INC.;;;	rel;	dsk	rel/si.scrolling;	put	defs/asm.conds	use	macros/standard;	put	defs/screen.equs;BASL1	equ	$2A		;used solely by scrolling routines;ClearEOL	ext		;in source/si.char.iovtab1		extvtab		ext;; This file contains the internal scrolling and generalized; terminal management routines.  The routines don't attempt to; save the state of anything, because things like scrolling; usually bash the entire world anyway.  No Problem.;; Scrolling of lines within the window are controlled by the; following variables.;; ScrollLineTop is the line closest to the top of the screen; that you want to scroll.  It is a single byte.;; ScrollLineBot is the line closest to the bottom of the; screen that you want to scroll.  It is also a single byte.;; ScrollDir should have the high bit set if you want to scroll; the lines up, or clear to scroll them down.;; ScrollDest is the line number that you want to scroll to. ; It is always in reference to the direction of the scroll,; that is, if moving lines down, this is where the bottom line; will go, if moving up, the top line.;;ScrollLineTop	ent		;the top line to scroll.	dfb	$00;ScrollLineBot	ent		;the bottom line to scroll.	dfb	$00;ScrollDir	ent		;high if scrolling lines up, else low.	dfb	$00;ScrollDest	ent		;destination line.	dfb	$00;ScrollWidth	dfb	$00	;width of scrolling area.;Scroll	ent			;call here after setting variables.;	lda	WindowRgt	lsr	sta	ScrollWidth	lda	ScrollDir	bpl	ScrollDown	;scroll these lines down.;ScrollUp	equ	*	;scroll lines up.;	lda	ScrollDest	;point BASL1 at destination.	jsr	vtab1	move	BASL;BASL1;	lda	ScrollLineTop	;point BASL at source.	jsr	vtab1;	jsr	MoveLine	;move one line.;	inc	ScrollDest	;bump to next line.	inc	ScrollLineTop;	lda	ScrollLineTop	cmp	ScrollLineBot	;done scrolling?	bcc	ScrollUp	;no.	beq	ScrollUp	;no.;	...	rts;ScrollDown	equ	*	;scroll lines down.;	lda	ScrollDest	jsr	vtab1		;point BASL1 at destination.	move	BASL;BASL1;	lda	ScrollLineBot	;point BASL at source/	jsr	vtab1;	jsr	MoveLine	;move a single line.	dec	ScrollDest	;get next line.	dec	ScrollLineBot	bmi	:exit		;hack: only happens on line# 0;	lda	ScrollLineBot	;done all lines?	cmp	ScrollLineTop	bcs	ScrollDown	;no.;:exit	rts;	do	If80Columns;MoveLine	equ	*	;subroutine which moves one line.;	ldy	#$00	sty	Page2		;scroll one side first.:loop1	lda	(BASL),y	;get character...	sta	(BASL1),y	;and place it at destination.	iny	cpy	ScrollWidth	bcc	:loop1;	dey			;now the other side.	sty	Page1:loop2	lda	(BASL),y	sta	(BASL1),y	dey	bpl	:loop2		;until done here.	rts;	else;MoveLine	equ	*	;for 40 columns.;	ldy	#$00;:loop	lda	(BASL),y	sta	(BASL),y	iny	cpy	#Columns	bcc	:loop	rts;	fin;; Now we handle special functions like inserting a line in the; middle of some others.;TV:InsLine	ent		;call with CV set to the line to insert at.;	lda	CV;TV:InsLine1	ent		;call here with line# in a-reg.;	sta	ScrollLineTop	;last line to move.	lda	WindowBot	sec	sbc	#$02		;InsertLine always pushes lines down.	sta	ScrollLineBot	;first line to move.	sta	ScrollDest	;move to this line+1.	inc	ScrollDest	cmp	ScrollLineTop	;already done?	bcc	:lstins	lda	WindowRgt;	do	If80Columns	lsr			;half the width if 80 columns.	fin;	sta	ScrollWidth	jsr	ScrollDown:lstins	lda	ScrollLineTop	;setup to clear original line.	sta	CV	lda	#$00	sta	CH	jsr	vtab		;come here if we're on the last line.	jsr	ClearEOL	;and clear the line that you were on.	rts;TV:DelLine	ent		;deletes the line in CV.;	lda	CV;TV:DelLine1	ent		;call here with line# in a-reg.;	sta	ScrollDest	;bash this line with others.	sta	ScrollLineTop	;set the top line to...	inc	ScrollLineTop	;1+ the current	line.	lda	WindowBot	sec	sbc	#$01	sta	ScrollLineBot	;and set this to the bottom of window.	cmp	ScrollLineTop	beq	:lstdel	lda	WindowRgt;	do	If80Columns	lsr			;half the width if hacking Apple card.	fin;	sta	ScrollWidth	jsr	ScrollUp	;now move the lines up.:lstdel	lda	ScrollLineBot	;and set the bottom.	sta	CV	lda	#$00	sta	CH	jsr	vtab	jsr	ClearEOL	;clear last line of display.	rts;