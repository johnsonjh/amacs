;-*- Mode: Merlin -*-;; File: chunkread.s;; Stuff for reading lines for maketags faster.  Too bad this; can't go in the main source, but Merlin can't handle the size; of the maketags.s file with this code in it.;SI:ReadFile equ *; jsr MLI dfb ReadFile da FReadParms rts;FReadParms equ *  ;parameter list for SI:ReadFile.; dfb $04FReadRef dfb $00FReadLoc da DataBufferFReadLen da DataBuffSzFLenRead da $0000;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;		Byte Oriented File I/O.;;;; Instead of really reading the file byte by byte, we use a;; static sized buffer, which gets filled when neccessary. ;; This means with a block sized buffer (512 bytes), and you;; are reading a 5k file byte by byte, instead of 5000 calls to;; ProDOS, you only have 10.  Okay?;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;RBufferOffset da $00  ;buffer offset into the read buffer.PrepFastRead ent   ;prepare the input file for reading.; sta FReadRef lda #$00 sta FLenRead sta FLenRead+1 sta ReadLast? rts;FReadByte ent   ;return the next byte from input, or BNE.; sty :yreg stx :xreg;; Is there any data left in the buffer?; lda FLenRead ora FLenRead+1 bne :buffer_byte ;yes, just scarf it.;; The data buffer is empty.  Refill it.; jsr SI:ReadFile bcs :at_eof;; And reset our pointer in it.; lda #$00 sta RBufferOffset sta RBufferOffset+1;; Read a single byte out of this buffer.;:buffer_byte decr FLenRead lda RBufferOffset clc adc #DataBuffer sta :pointer+1 lda RBufferOffset+1 adc #>DataBuffer sta :pointer+2:pointer lda DataBuffer incr RBufferOffset ldy #$00:exit php ldy :yreg ldx :xreg plp rts;:at_eof lda #$FF bmi :exit;:xreg dfb $00:yreg dfb $00;ReadLast? ent   ;when non-zero, already exhausted input file. dfb $00;FastReadLine ent   ;read a line from the file.;; Read a line from the file.  The line returned must be less; than 255 characters in length.  Characters after the 255th; are discarded.  The line is placed into LineBuff, in STR; format.  The <CR> at the end of the line is not included.; lda ReadLast? bmi :exit ;sorry, the file is exhausted.; ldx #$00:line_loop jsr FReadByte bne :last_byte ;already have the last byte. ora #$80;; If this is a RETURN, then end the line here.  Otherwise, just; add this character to the line.; cmp #Return beq :got_line; inx sta LineBuff,x bne :line_loop;; In case of line buffer overflow, discard characters past the; end of the line.; dex bne :line_loop ;always.;:got_line stx LineBuff lda #$00:exit rts;:last_byte lda #$FF sta ReadLast? bmi :got_line ;always.;