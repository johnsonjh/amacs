;-*- Mode: Merlin - TagsMode: MerlinRel -*-;;File    :MAKETAGS;Author  :Steve Linberg;Address :21 Commonwealth Terrace;         Brookline, MA. 02146;Phone   :(617) 232-4008;; This file is the sole property of Brian Fox, and his; dis-associated company, Creative Thinking, INC.;; This file may not be reproduced in any way or fashion,; without the explicit written permission of Brian Fox.;; This file contains valuable trade secrets used by Creative; Thinking, INC., in the production and manufacture of its; products, and as such is protected under the copyright laws; of this state.;; Copyright 1986, Brian Fox; Copyright 1986, Creative Thinking, INC.;; Authorship credits:;;  The original version of MAKETAGS was written for ECP-8 by;  Steven Lindberg, under the direction of Brian Fox.  Steven;  did a great job, and we used his code for almost 2 years. ;  When we decided to sell MAKETAGS as part of AMACS, we had to;  support those users who did not use a "shell" processor, and;  thus the reason this is now a system file.  Brian Fox did;  the consolidation, conversion, and conditionalization.;; put defs/maketags.equs; do IfSystemVerObjectType = $FFObjectDest = $2000 elseObjectType = $F0ObjectDest = $6000 fin; org ObjectDest typ ObjectType; dsk maketags; use macros/standard put defs/prodos.equsItem mac   ;for pretty parser things. dfb ]1 dfb ]2 da ]3 eom;fopen mac   ;for pretty calls to Open.; load OpenPathName;]1 load OpenCopyBuff;]2 jsr Open eom;pi_Flag = $00   ;set variable to $FFpi_NegFlag = pi_Flag+1  ;set variable to $00pi_String = pi_NegFlag+1 ;copy string to variablepi_UserItem = pi_String+1  ;jump to user routine.;Return = $8D  ;ascii return char.EOL = Return ;End Of Line char, same thing.Tab = $89  ;ascii tab char.Space = $A0  ;ascii space char.SingleQuote = "'"DoubleQuote = $A2;; Prepare to accept command line from ProDOS.  Isn't this the; right thing?; jmp Main; do IfSystemVer dfb $EE,$EE ;this and the previous JMP are magic. dfb 255  ;max buffer length.SystemArgs ds 255  ;length byte, string data. fin;; Variables:;EndOfModes da $0000 ;end of modes list.EndOfTags da Tags ;current place for tags.;SourceRef dfb $00  ;refnum for source file.TagsRef dfb $00  ;refnum for tags file.CurrRef dfb $00  ;refnum for current file.ModesRef dfb $00  ;refnum for mode things.;DupTagsOK? dfb $00  ;flag for allowing duplicate tags.Verbose? dfb $00  ;minus means turn on info messages.;AbortStack dfb $00  ;place to save stack state upon entry.Byte dfb $00  ;place to hold byte for disk i/o.GlobalEOF dfb $00  ;minus if EOF found for any file.;; Code begins here.;Main equ *  ;the program.; do IfSystemVer lda #Return jsr $C300 ;yechh. jsr PrintMessage dfb Return asc "Maketags (stand-alone) Version 1.0" dfb Return asc "Authored by Steven Lindberg and Brian Fox" dfb Return asc "Copyright (C) 1985, 1986, 1987 Creative Thinking," asc " Included." dfb Return,Return asc "(" brk;:ora80 lda SystemArgs+1,y ora #$80 sta SystemArgs+1,y iny cpy SystemArgs bcc :ora80; load temp;SystemArgs jsr PrintSTR; jsr PrintMessage asc ")" dfb Return,Return dfb $00; jsr ZapMem ;zap out silly ProDOS bitmap. fin; tsx stx AbortStack ;save stack state for error exit. jsr ClearVars ;zero the filename strings, etc... jsr GatherArgs ;use a nice generic parser for this. bne :badargs ;sure is nice to tell me this. jsr ArgsValid? bne :badargs jsr OpenFiles ;open all files, make sure ok. jsr GetModesFile ;locate tags processors. jsr SetDefMode ;set default mode as supplied by Luser.:loop jsr ProcessFile ;process one file for tags. beq :loop ;and so on. jsr WriteTags ;write the tags to the file. jsr CloseFiles ;close all files. jmp ReallyExit:badargs jsr PrintMessage asc "Usage: maketags " asc "[-dv [-u Mode] [-m DefMode] [-f ModesFile] ] " asc "tagsfile destfile" ;there, there, MERLIN dfb Return,$00 jmp AbortSelf;ZapMem equ *  ;don't let ProDOS worry about buffer space.;:nomap lda #$00 ldx #$00:clear sta SysMemMap,x inx cpx #24 bcc :clear rts;ClearVars equ *  ;clear the equates that uset to be vars.; lda #$00 sta ModesFile ;might be specified. sta DefModeText ;might be specified. sta ForcedMode ;might be specified. sta SourceFile ;should be specified. sta TagsFile ;should be specified. sta ModeFileText ;never specified but maybe leftover in RAM. rts;ArgsValid? equ *  ;make sure we have good args.; lda SourceFile beq :fail lda TagsFile beq :fail lda #$00 ;win rts:fail lda #$FF ;lose rts;GatherArgs equ *  ;gather the arguments.; load temp;ArgsList jsr ParseArgs ;parse the args. rts   ;simple.;ArgsList equ *  ;the arguments list.; Item "D";pi_Flag;DupTagsOK? Item "V";pi_Flag;Verbose? Item "F";pi_String;ModesFile Item "M";pi_String;DefModeText Item "U";pi_String;ForcedMode; dfb $00  ;no more items.; da SourceFile ;first string is source file. da TagsFile ;second string is dest file.; da $0000 ;end of items list.;GetModesFile equ *  ;load the file with the tags modes.;; Get the modes file from the current default directory, or; if not found there, try the root volume.;; The ModesFile has the following format:;; modename:filename; ... lda ModesFile ;anything in here? bne :gotmod ;yes, so go ahead; ldy DefModesFile ;no, so use default:loop lda DefModesFile,y sta ModesFile,y dey bpl :loop lda #$01 sta :filefnd? ;init this - similar to OpenFiles;; Got pathname - read into ModesList.;:gotmod fopen ModesFile;FileBuff3 bcs :opnerr ;open error - check for file not found sta ModesRef sta ReadRef ;read from this file load temp;ModesList:loop2 jsr ReadLine ;read a line from the file bcs :done ldy LineBuff:loop3 lda LineBuff,y ;copy it into ModesList jsr UpperCon sta (temp),y dey bne :loop3 lda LineBuff sta (temp),y ;dont uppercon length lda LineBuff ;point temp ahead sec   ;add in length adc temp sta temp bcc :loop2 inc temp+1 bne :loop2 ;always:done lda #$00 sta GlobalEOF ;reset this move temp;EndOfModes lda ModesRef jsr Close bcs :err2 ;unlikely rts:error jsr PrintMessage asc "Can't open Modes file " dfb $00 load temp;ModesFile jsr PrintSTR jsr PrintMessage asc "." dfb Return,$00 jmp AbortProg:err2 jmp sysdeath:opnerr cmp #er_FileNotFnd ;we tolerate this one, here bne :error;; We did not find the file in the default dir.  Try it in the; root dir - get the prefix and append the text in ModesFile; to the device name.  If that isn't found (second time; through), give up.; dec :filefnd? ;starts at $01. bmi :error ;if we've tried twice - default and root. jsr MLI dfb GetDefPrefix ;file not found - try root dir. da :pfxparms lda :pfx ;length beq :error ;no prefix. ldy #$01 ;now look for ending slash, always there.:loop4 iny   ;skip 1st slash lda :pfx,y ora #$80 ;bloody hibits cmp #"/" ;will always be found bne :loop4 ldx #$00 ;index into ModesFile:loop5 cpx ModesFile ;now append text in modesfile bcs :gottxt iny inx lda ModesFile,x sta :pfx,y bne :loop5 ;always:gottxt sty ModesFile ;set new length:loop6 lda :pfx,y sta ModesFile,y ;now copy whole thing over ModesFile. dey bne :loop6 ;don't overwrite length byte. jmp :gotmod ;and try again.:pfxparms dfb $01 da :pfx:pfx ds 64:filefnd? dfb $00  ;used in looking for modesfile.;DefModesFile str "MODESFILE" ;default modesfile filename.;SetDefMode equ *  ;set the default mode.;; The default mode will either be supplied by the Luser on; the input line ("-m MerlinRel") or come from the first line; in the modes file.; lda DefModeText bne :usrmod ;there is some supplied text. parse it.;:def0 ldy #$00 ;no supplied text - take 1st line of mode file:loop lda ModesList,y ;look for 1st ":" char in ModesList cmp #":" beq :found iny bne :loop ;almost always; jsr PrintMessage asc "Bad ModesFile format." dfb Return,$00 jmp AbortProg;:found dey   ;point to char before ":" sty DefModeText ;set length:loop2 lda ModesList,y ;copy text of default mode sta DefModeText,y dey bne :loop2 ;don't copy length byte, it's wrong:zip rts;:usrmod load temp;DefModeText jsr FindModeFile ;find STR string in ModesList, ret # in A bcs :notfnd ;default mode text not found. rts;:notfnd jsr PrintMessage asc "Mode '" dfb $00 load temp;DefModeText jsr PrintSTR jsr PrintMessage asc "' not found in file.  Default mode will be '" dfb $00; jsr :def0 ;get default text from file; load temp;DefModeText jsr PrintSTR jsr PrintMessage asc "'." dfb Return,$00 rts;FindModeFile equ *  ;find the STR string in (temp) in ModeList.;; parse the filename into ModeFileText.; load temp1;ModesList ldx #$FF ;index, use for counting strings;:loop inx lda temp1 cmp EndOfModes bne :seek lda temp1+1 cmp EndOfModes+1 bne :seek rts   ;with carry set - mode not found;:seek ldy #$00 ;looking for mode name. ModeName:ModeFile lda (temp),y ;length of mode text we want tay iny   ;point to char beyond last char lda (temp1),y ;same lengths if this is a ":" cmp #":" bne :next ;nope;:loop2 dey   ;get back to real length beq :found ;don't compare lengths, they're not equal lda (temp),y jsr UpperCon cmp (temp1),y beq :loop2;	...:next ldy #$00 lda (temp1),y ;point temp1 to next string sec   ;add length byte adc temp1 sta temp1 bcc :loop inc temp1+1 jmp :loop;:found txa   ;string offset pha   ;save this; ldy #$00 lda (temp1),y sta :len ;length of 'mode:filename' string.; lda (temp),y ;get length of 'mode' string from caller tay iny   ;point to char ":" in list; ldx #$01 ;index into ModesFile (use again):loop3 cpy :len bcs :gotln iny lda (temp1),y sta ModeFileText,x inx bne :loop3:gotln dex stx ModeFileText ;set length; pla   ;restore string offset clc   ;win rts;:len dfb $00;; Following is the file i/o stuff, copied from Copyfile.;Open equ *  ;open a file, return reference number in a-reg; jsr MLI dfb OpenFile ;Prodos open code da OpenParms bcs :exit ;don't disturb error code. lda OpenRef:exit rts;OpenParms equ *  ;parameters for Open.; dfb $03  ;parameter count.OpenPathName da $0000 ;address of pathname.OpenCopyBuff da $0000 ;address of 1k file buffer for ProDOS.OpenRef dfb $00  ;returned reference number of file.;Read equ *  ;read from file refnum in a.; jsr MLI dfb ReadFile da ReadParms rts;ReadParms equ *  ;parameters for Read.; dfb $04  ;parameter count.ReadRef dfb $00  ;reference number for file to read.ReadAddr da Byte ;destination to read.AmountToRead da 1  ;amount of data to read.AmountRead da $0000 ;amount actually read.;Write equ *  ;write a byte to a file.; and #$7F sta Byte jsr MLI dfb writeFile da WriteParms rts;WriteParms equ *  ;parameters for Write.; dfb $04  ;parameter count.WriteRef dfb $00  ;reference number for file to write.WriteAddr da Byte ;tagsination of data to write.WriteSize da 1  ;amount of data to write. da $0000 ;amount actually written.;CloseFiles equ *  ;close source and tags.; lda SourceRef jsr Close ;ignore errors; lda TagsRef sta EOFRef; jsr MLI dfb GetFilePos da EOFParms; jsr MLI dfb SetEndOfFile da EOFParms; lda TagsRef ;..Close equ *  ;close the file with refnum in a.; sta CloseRef; jsr MLI dfb CloseFile da CloseParms rts;EOFParms equ *  ;parameters for GetFilePos, and SetEndOfFile.; dfb $02  ;there are 2 of them, Steve. (yeah OK, OK...)EOFRef dfb $00 ds 3  ;the length/filepos of this file.CloseParms equ *  ;parameters for Close.; dfb $01  ;parameter count.CloseRef dfb $00  ;refnum of file to close.;Create equ *  ;create a file. jsr MLI dfb CreateEnt da CreateParms rts;CreateParms equ *  ;parameters for Create.; dfb $07  ;parameter count. da TagsFile ;address of pathname to create. dfb $C3  ;access bits for file to create. dfb $04  ;type of file to create. (text) da $0000 ;auxiliary file info. dfb $00  ;storage type info, set by system. da $0000 ;creation date, leave blank. da $0000 ;creation time, leave blank.;OpenFiles equ *  ;open the source and tags files.;; Open source file.;:opsrc fopen SourceFile;FileBuff1 sta SourceRef bcs :error; lda #$00 sta :opnerr ;no error opening tags file yet.;; Open/Create tags file.;:open fopen TagsFile;FileBuff2 sta TagsRef bcc :out ;a win, copy the file reference numbers.; ldx :opnerr bmi :error ;already created, but can't open.; jsr Create ;try to create the file. bcs :error ;can't. Barf on caller. dec :opnerr ;already had one of these. bmi :open ;retry the open now. (Always taken);:out jsr InitRW clc rts;:error jmp sysdeath;:opnerr dfb $00  ;gets $FF if first tags open fails.InitRW equ *  ;init the ref numbers for Read and Write.; lda SourceRef sta ReadRef lda TagsRef sta WriteRef rts;ReadLine equ * ;read a line one byte at a time from source.; lda GlobalEOF beq :setidx  ;not at end of file yet. dec GlobalEOF ;in case we want to read another file. sec   ;set losing status. rts;:setidx sta :index:loop inc :index ldy :index jsr Read  ;read a byte bcs :err?  ;maybe error, maybe eof. lda Byte  ;returned byte read ora #$80 sta LineBuff,y cmp #EOL  ;end of line char? bne :loop  ;no, so get next character.;:EOL dey   ;point to char before EOL. sty LineBuff ;set length of line;; Now make sure we got a string with something in it.; ldy #$00:loop2 cpy LineBuff beq ReadLine ;if string is all whitespace iny lda LineBuff,y jsr WhiteSpace? beq :loop2;	...			;if it falls through, line is ok:out clc   ;winning status rts;:err? cmp #er_EndOfFile ;read AT end of file? bne :error lda #$FF sta GlobalEOF bmi :EOL  ;found eof, so, found EOL.;:error jmp sysdeath;:index dfb $00;ProcessFile equ *  ;do one file's worth of tags things.; jsr Abort? lda #$00 sta GlobalEOF ;clear this psuedo-error so we may continue.; jsr GetCurrFile ;set the file to get tags from. bcc :hvfile ;if we are at the end of the source file.; lda GlobalEOF bmi :tgout jsr TagComplain:tgout jmp :done;:hvfile lda #$00 sta GlobalEOF ;clear this psuedo-error so we may continue.; jsr GetModeLine ;read the modeline into LineBuff. bcc :fileok jmp :badfil ;if file is phooed.;:fileok jsr GetMode ;accept tags mode from the 1st line, if any. jsr LoadMode ;read the tags handler for this mode. bcs :nomode ;Luser?; jsr PsuedoTag ;write the name of the current file to table.; lda CurrRef jsr PrepFastRead jsr StartTagFile ;do user-specified file starting things.;:loop jsr Abort? ;be nice. jsr FastReadLine ;read a line from the current file. bne :out ;if we are at the end. jsr IsTag? ;see if the line contains a tag. bne :loop ;no, so keep reading. bit DupTagsOK? ;yes, so are dupes OK? bmi :add ;yes, so add it regardless. jsr TagExists? ;no, so see if it's around first. beq :loop ;if yes, skip it:add jsr AddTag ;yes, so add it to the tags list bcc :loop ;if room to add.; jsr PrintMessage asc "Tags table overflow! Writing tags..." dfb Return,$00 jsr WriteTags ;else flush table. load EndOfTags;Tags ;reset tags table. jmp :add ;and add again.; jsr EndTagFile ;do user-specified closing things.;:out lda CurrRef ;close the file we processed. jsr Close bcs :error lda #$00 ;win. rts   ;that's all.;:done lda #$FF ;fail, no more files to process. rts;:error jmp sysdeath ;die.;:nomode jsr PrintMessage asc "No processing file found for " dfb $00 load temp;CurrModeText jsr PrintSTR jsr PrintMessage asc " tags. Skipping file " dfb $00 load temp;CurrFile jsr PrintSTR jsr PrintMessage asc "." dfb Return,$00 jmp :out ;skip file.;:badfil jsr PrintMessage asc "File " dfb $00 load temp;CurrFile jsr PrintSTR jsr PrintMessage asc " has zero length.  Skipping it..." dfb Return,$00 jmp :out;TagComplain equ *  ;complain about file in CurrFile.; jsr PrintMessage asc "Can't open the file " dfb $A2  ;quote character. brk load temp;CurrFile jsr FixPath load temp;CurrFile jsr PrintSTR jsr PrintMessage dfb $A2  ;quote character. asc ".  Skipping it..." dfb Return,$00 rtsGetCurrFile equ *  ;get the file to process from the source file. lda SourceRef ;set up to read from this file. sta ReadRef jsr ReadLine ;no cleaning up allowed. bcs :out ldy LineBuff ;take filename from LineBuff.:loop lda LineBuff,y sta CurrFile,y dey bpl :loop fopen CurrFile;FileBuff3 ;already in STR format, thanx bcs :out  ;couldn't open? sta CurrRef  ;save the reference number:out rts    ;and return, carry with status.;GetModeLine equ *  ;read the 1st line of the source file.; lda CurrRef sta ReadRef jmp ReadLine;PsuedoTag equ *  ;write the tag name into the table.; load temp;CurrFile jsr FixPath ldy CurrFile:loop lda CurrFile,y sta Tag,y dey bpl :loop; bit Verbose? bpl :addit; jsr PrintMessage asc "Processing file " dfb $00 jsr PrintSTR ;temp is already set up jsr PrintMessage asc " as " dfb $00 load temp;CurrModeText jsr PrintSTR lda #Return jsr CharOut;:addit jmp AddTag;GetMode equ *  ;set CurrModeText accodring to specified mode.;; /addition/: If there is text in ForcedMode, use it and; ignore the mode line.;; Look for the text "TagsMode:" in the first line.  If found,; take the next word as the mode.  If not found, look for; just "Mode:" and take the next word.  If still not found,; use the default mode.;; The first line of the file is in LineBuff.; lda ForcedMode beq :noforc ldy ForcedMode:loop0 lda ForcedMode,y sta CurrModeText,y dey bpl :loop0 rts:noforc load temp;TagsText ;look for this string. jsr SearchLine bcc :getmod ;found. load temp;ModeText ;not found, so look for this string. jsr SearchLine bcc :getmod;:nomode ldy DefModeText:loop lda DefModeText,y ;not found, so use default mode. sta CurrModeText,y dey bpl :loop; jsr PrintMessage asc "No mode specified in " dfb $00 load temp;CurrFile jsr PrintSTR jsr PrintMessage asc ".  Processing as " dfb $00 load temp;CurrModeText jsr PrintSTR jsr PrintMessage asc "." dfb Return,$00 rts;:getmod cpx LineBuff ;found mode. Now get the word after X. bcs :nomode ;oops, found mode word but no mode inx lda LineBuff,x jsr AlphaChar? ;skip all non-alpha chars bne :getmod ldy #$01 ;index into CurrModeText:loop2 sta CurrModeText,y cpx LineBuff ;overflow? bcs :gotmod ;yes, so call it here inx lda LineBuff,x jsr AlphaChar? ;now take only alpha chars. bne :gotmod iny bne :loop2:gotmod sty CurrModeText ;set len rts;SearchLine equ *  ;search LineBuff for STR string in (temp); ldy #$00 lda (temp),y ;get len of string to search for sta :len lda LineBuff sec sbc :len ;set max offset to search into LineBuff. bmi :fail ;too small. sta :maxoff inc :maxoff ;up to this is OK, beyond is pointless. inc :maxoff ;and make it one-based.  this works.; ldx #$00 ;index into LineBuff:loop cpx :maxoff ;searched entire string? bcs :fail ;yes.  No mode specified, use default mode. ldy #$00 ;set index into temp.:loop2 cpy :len ;compared to end of string? bcs :found ;yes, we found it. inx   ;no, so check next char. iny lda LineBuff,x jsr UpperCon ;so case dozzn't matter cmp (temp),y bne :loop beq :loop2;	---			;never fall through.:found clc   ;win. rts;:fail sec   ;fail. rts;:len dfb $00  ;length of string to look for:maxoff dfb $00  ;max depth of LineBuff to go into while searching;TagsText str "TAGSMODE:"ModeText str "MODE:";LoadMode equ *  ;load the mode processor.;; Take the text in CurrModeText, search ModeList for it, and; take the filename out.  read the code in.; load temp;CurrModeText jsr FindModeFile ;get the mode string in ModeFileText bcs :out ;no mode found. complain upon return.; jsr SameMode? ;see if we are in the same mode as last file bne :notok ;yes, so don't re-load. clc:out rts;:notok fopen ModesFile;FileBuff4 bcs :error sta ModesRef sta ReadRef ;now read the file. load ReadAddr;UserFuncAddr load AmountToRead;MaxTPSize ;max size of processing code. jsr Read ;read with these parameters. bcs :err load ReadAddr;Byte load AmountToRead;1 ;re-set old parameters lda ModesRef jsr Close bcs :err:ok clc   ;win. rts;:error pha jsr PrintMessage asc "Can't open the mode processing file " dfb $00 load temp;ModesFile jsr PrintSTR jsr PrintMessage asc "." dfb Return,$00 pla;;;	jmp	sysdeath	;fix this.:err jmp sysdeath;SameMode? equ *  ;same as previous mode?; ldy ModeFileText:loop lda ModeFileText,y ;used same file for processing? cmp ModesFile,y bne :move ;no. dey   ;maybe. bpl :loop;	...			;yes. lda #$00 ;win. rts;:move ldy ModeFileText ;copy text into filename for processor to load:loop2 lda ModeFileText,y sta ModesFile,y dey bpl :loop2 rts   ;with not equal status;IsTag? jmp (UserIsTag?) ;get tag from LineBuff, if any.StartTagFile jmp (UserStartTag) ;do tagfile starting things, if any.EndTagFile jmp (UserEndTag) ;do tagfile ending things, if any.;TagExists? equ *  ;see if a tag exists in the table.; load temp;Tags;:loop jsr PastEnd? ;completely robust. end of table? bne :seek lda #$FF ;fail - tag doesn't exist. rts;:seek ldy #$00 ;get length byte of tag in table. lda (temp),y cmp Tag  ;lengths match? beq :comp ;yes, so compare text.;:next jsr NextTag ;next tag please. jmp :loop ;and continue.;:comp cpy Tag  ;compared to end of string? bcs :eq  ;yes, tags are equal. iny lda (temp),y cmp Tag,y beq :comp; bne :next ;always;:eq lda #$00 ;shouldn't be necessary, but i'm cautious rts;AddTag equ *  ;add the STR string in Tag to the tags table.; move EndOfTags;temp ;first make sure there's enough room.; lda #>TagsTop ;get difference between hi-bytes in A. sec sbc temp+1 bcc :noroom ;if we're over top. beq :noroom ;if we're at top. cmp #$02 ;more than $100 bytes remaining in table? bcs :add ;yep, so add.; lda #TagsTop ;get number of bytes remaining. sec sbc temp cmp Tag  ;enough room to add tag? bcs :add ;yep, so add.:noroom sec   ;nope, so don't add. rts   ;fail.;:add ldy Tag:loop lda Tag,y sta (temp),y dey bpl :loop; jsr NextTag ;make temp point to next tag (there isn't one) move temp;EndOfTags ;and set this as the top. clc   ;win.:out rts   ;tag added.;WriteTags equ *  ;write the tags table to the Tags file.; bit Verbose? bpl :main; jsr PrintMessage asc "Writing tags file..." dfb Return,$00;:main load temp;Tags;:done? jsr PastEnd? ;are we past the end of the tags table? bne :write ;nope. rts   ;yup.;:write ldy #$00 ;get length of tag to write lda (temp),y sta :len:loop cpy :len ;string written? bcs :cr  ;yes, so write cr too. iny lda (temp),y jsr Write bcc :loop jmp sysdeath ;uh-oh, write error:cr lda #EOL jsr Write bcc :next jmp sysdeath:next jsr NextTag ;make temp point to the next tag. jmp :done?;:len dfb $00  ;the usual;NextTag equ *  ;make temp point to the next tag.; ldy #$00 ;get length lda (temp),y sec   ;add in length byte adc temp sta temp bcc :out inc temp+1:out rts;PastEnd? equ *  ;see if temp is past EndOfTags.; lda temp cmp EndOfTags bne :out lda temp+1 cmp EndOfTags+1:out rts;sysdeath equ *  ;die horribly.; jsr PrintError;	...AbortProg equ *  ;abort this program.; jsr CloseFiles jsr PrintMessage dfb Return,Return asc "Program halted." brk ;..AbortSelf equ *  ;just die.; do IfSystemVer jsr PrintMessage dfb Return,Return asc "Press a key to continue:" brk;:wait lda $C000 bpl :wait sta $C010 finReallyExit equ * ldx AbortStack txs; do IfSystemVer jsr $BF00 dfb $65 da :quit:quit dfb 4,0,0,0,0 else rts fin;Abort? equ *  ;abort in case of use intervention.; lda $C000 bpl :no cmp #$87 beq :yes cmp #$9B beq :yes:no rts:yes jsr PrintMessage asc "User abort. No tags written." dfb Return,$00 jmp AbortProg;Items = $00  ;address of item list (temp really);Argument = $300 ;argument string.;Flag dfb $00  ;place to hold character while searching listItemType dfb $00  ;type of item specified in listItemVect da $0000 ;address of item thing.;ParseArgs ent   ;parse an arguments list.; ldy #$00 sty :index jsr InitArgGet;:loop jsr NextArg ldx Argument beq :done ;no args present. lda Argument+1 ora #$80 cmp #"-" ;flag? bne :string ;no, so begin reading strings.;:flag lda Argument+2 ;handle flag. jsr DoFlag bne :done ;bad arg - return to caller jmp :loop;:string lda #$00 ;find end of list by specifiying bad flag jsr ScanForFlag ;this will always fail - just what we want.; iny   ;y now points to 1st byte of 1st string addr.;:loop3 sty :index ;here is where the string addresses start lda (Items),y sta temp1 ;copy string addr to temp1 iny lda (Items),y sta temp1+1; lda temp1 ora temp1+1 ;zero? beq :done ;if so, no more string space. return.; ldy Argument ;length of string to move:loop4 lda Argument,y sta (temp1),y dey bpl :loop4 ;string is moved.; jsr NextArg beq :done ;no more. ldy :index ;another? ok iny iny   ;addresses are 2 bytes long bne :loop3 ;keep copying strings.;:done rts:index dfb $00;FindFlag equ *  ;find flag char in a, return y pointing to it.; jsr UpperCon ;..ScanForFlag equ *  ;scan for char without UpperConning it.; sta Flag ldy #$00 ;point to beginning of flag table.:check lda (Items),y beq :fail ;zero byte means no more flags jsr UpperCon cmp Flag beq :out iny   ;skip type byte iny iny   ;skip address of handler iny bne :check ;always:out clc rts:fail lda Flag ;return offending char sec rts;InitArgGet equ *  ;prepare to process args.; ldx #$01 stx ArgIndex rtsArgIndex dfb $00 do IfSystemVer;NextArg equ * ;return next arg in Argument. BEQ means none left.; ldy #$00 ;index into Argument.; ldx ArgIndex jsr :skipwhite ldx ArgIndex cpx SystemArgs bcs :none_left; lda SystemArgs,x cmp #DoubleQuote ;this argument is delimited? beq :delim cmp #SingleQuote bne :gobble;:delim sta :delimiter dey:delim_loop inx iny cpx SystemArgs bcs :got_delim lda SystemArgs,x ora #$80 sta Argument+1,y cmp :delimiter bne :delim:got_delim inx stx ArgIndex jmp :done;:gobble lda SystemArgs,x ora #$80 jsr WhiteSpace? beq :gobbled iny sta Argument,y cpx SystemArgs bcs :gobbled inx bne :gobble;:gobbled stx ArgIndex:done sty Argument:none_left tya rts;:skipwhite dex:skiploop inx cpx SystemArgs bcs :skipdone lda SystemArgs,x jsr WhiteSpace? beq :skiploop:skipdone stx ArgIndex rts;:delimiter dfb $00; else;GETARG = $10  ;command to get next arg.CPMLI = $2008 ;command handler.;NextArg equ *  ;get the next arg from CPMLI.; lda ArgIndex cmp #$01 bne :getit dec ArgIndex beq :done; ldx #GETARG jsr CPMLI:done lda Argument rts; fin;WhiteSpace? equ * ora #$80 cmp #Space beq :exit cmp #Tab:exit rts;;DoFlag equ *  ;handle flag character in a-reg.; jsr FindFlag bcc :gotit ;carry clear if flag found. rts   ;set if not.;:gotit jsr GetItemInfo ;get info about the item.; lda ItemType asl   ;double for offset tay move ItemTable,y;SMod+1;SMod jsr $0000 ;self-modifying address - nasty, but hey; lda #$00 ;set flag OK status rts;;GetItemInfo equ *  ;get information from the item in (Items),y; iny   ;skip character byte, we don't need it lda (Items),y ;copy item type sta ItemType iny lda (Items),y ;and address of item thing. sta ItemVect iny lda (Items),y sta ItemVect+1 rts;ItemTable equ *  ;vectors for item handlers.; da hd_Flag da hd_Negate da hd_String da hd_UserItem;hd_Flag equ *  ;set a flag.; move ItemVect;temp1 ldy #$00 lda #$FF sta (temp1),y rts;hd_Negate equ *  ;negate a flag.; lda Argument cmp #$02 ;just -n? beq :negate ;yes, so negate default item's vector. lda Argument+3 ;get text of flag to negate jsr FindFlag bcs :out ;not found.; jsr GetItemInfo lda ItemType bne :out ;can only negate flag type items. Flags are 0.;:negate move ItemVect;temp1 lda #$00 tay sta (temp1),y;:out rts   ;flag is negated.;hd_String equ *  ;accept a string for this flag.; jsr NextArg beq :out ;no args.; move ItemVect;temp1; ldy Argument ;len of flag:loop lda Argument,y sta (temp1),y dey bpl :loop;:out rts   ;string is copied.;hd_UserItem equ *  ;handle a user item.; jmp (ItemVect);UpperCon ent   ;convert a-reg to upper-case.; ora #$80 cmp #"a" bcc :exit cmp #"z"+1 bcs :exit and #$DF:exit rts;AlphaChar? ent   ;t if a-reg is alphabetic character.; sta :char jsr UpperCon cmp #"A" bcc :exit ;no. cmp #"Z"+1 bcs :false lda #$00 beq :exit:false lda #$FF:exit php lda :char plp rts:char dfb $00;PathBuffer equ *  ;space for passed in prefix. ds 64;FixPath ent   ;take the pathname in (temp) and fix it.; ldy #$00 lda (temp),y ;get length of pathname beq :nopath ;if zero, no path - quit. iny   ;ldy #$01 lda (temp),y ora #$80 ;fix hi-bits cmp #"/" ;fully qualified path? beq :hvpath ;yes, so everything's honky-dorey;; If not, call GetPrefix and prepend.; push temp ;save temp through ProDOS call. jsr MLI dfb GetDefPrefix ;get my prefix. da FixParms ;here. pop temp ;restore temp.; ldx PathBuffer ;get length of returned prefix ldy #$00 lda (temp),y ;and length of supplied partial prefix sta :parlen ;put it here for quick reference iny   ;ldy #$01:copy lda (temp),y ;get a partial prefix char ora #$80 sta PathBuffer+1,x ;and append it cpx #63  ;max length of a pathname bcs :endcop ;name hit max length inx iny dec :parlen bne :copy:endcop stx PathBuffer ;new pathname length; ldy PathBuffer ;now copy it back to (temp):loop lda PathBuffer,y ora #$80 sta (temp),y dey bne :loop ;don't ora length byte, Brian. lda PathBuffer,y ;nice length byte. sta (temp),y ;set it.;:hvpath clc   ;set winning status rts:nopath sec   ;or losing rts;:parlen dfb $00  ;space to store length of partial prefix;FixParms equ *  ;parameters for GetPrefix.;:count dfb $01:buffer da PathBuffer;GetErrText ent   ;return temp = dci string of error in a-reg.;; Look up a-reg's error code in the table, skip that many dci; strings, return pinter in temp. Return with carry set if; there is no error text.; ldx #$00 ;get ready to search the table.:loop1 cmp ErrTable,x ;grab a code beq :found ;yes, so get the address inx   ;no, so keep looking. cpx #ErrTable_X-ErrTable bcc :loop1 ;if not end, keep looking. bcs :gettxt ;always taken.;:found clc:gettxt php pha   ;save error number. txa   ;times 2 for pointer index. asl tax move ErrorText,x;temp pla   ;restore error number. plp   ;restore carry state. rts;ErrTable ent   ;table of error codes; dfb er_BadDisk dfb er_NoDevice dfb er_WriteProt dfb er_BadPath dfb er_NoSuchPath dfb er_NoSuchVol dfb er_FileNotFnd dfb er_Access;ErrTable_X equ *;ErrorText ent   ;table of matching pointers.; da tx_BadDisk  ;I/O error encountered. da tx_NoDevice  ;No device connected. da tx_WriteProt ;Device write protected. da tx_BadPath  ;Pathname has invalid syntax. da tx_NoSuchPath ;Pathname cannot be followed. da tx_NoSuchVol ;Volume not mounted. da tx_FileNotFnd ;File not found. da tx_Access  ;Illegal access attempt.;ErrorText_X equ *  ;end of understood errors.;unknown da tx_GenError ;ProDOS error # (prints ProDOS error #);; The actual messages begin here - in dci format.;tx_BadDisk dci "I/O error encountered"tx_NoDevice dci "No device connected"tx_WriteProt dci "Device write protected"tx_BadPath dci "Pathname has invalid syntax"tx_NoSuchPath dci "Pathname cannot be followed"tx_NoSuchVol dci "Volume not mounted"tx_FileNotFnd dci "File not found"tx_Access dci "Illegal access attempt"tx_GenError dci "ProDOS error $";PrintError ent   ;print an error from a code.; jsr GetErrText; php   ;save error state, and number. pha; push temp move OpenPathName;temp jsr PrintSTR pop temp; jsr PrintDCI ;print the error message.; pla   ;restore error number, and state. plp; bcc :exit ;all of error message printed. jsr PrByte ;else, print the prodos error #.;:exit lda #Return jsr CharOut rts; do IfSystemVerOUTVECT = $36  ;Apple output vector. elseOUTVECT = $200F ;ECP output vector. fin;CharOut ent   ;output a-reg to stdio. jmp (OUTVECT);PrintMessage ent  ;print z-string after call. Uses temp2 ($04).; pop temp2 ldy #$00:loop incr temp2 lda (temp2),y beq :done jsr CharOut jmp :loop:done push temp2 rts;PrintSTR ent  ;print a STR string.; ldy #$00 lda (temp),y sta :len:loop cpy :len bcs :done iny lda (temp),y jsr CharOut jmp :loop:done rts;:len dfb $00;PrintSTRCR ent  ;print a str string & cr.; jsr PrintSTR lda #Return jmp CharOutPrintDCI ent    ;print a DCI string in (temp).; ldy #$00 lda (temp),y  ;get 1st char and #$80  ;mask all but hi-bit sta :mask:loop lda (temp),y pha ora #$80 jsr CharOut pla and #$80 cmp :mask  ;hi-bit state the same? bne :done iny bne :loop:done rts;:mask dfb $00;PrByte ent   ;print hex value of byte in a-reg.; pha lsr lsr lsr lsr jsr :nibble pla and #$0F:nibble ora #"0" cmp #"9"+1 bcc :print adc #$06:print jmp CharOut; put chunkread;