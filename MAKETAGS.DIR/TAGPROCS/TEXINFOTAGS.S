; -*- Mode: Merlin -*-;; File: tagprocs/texinfotags.s;; This file contains the routines necessary to process texinfo; files for tags.; put defs/maketags.equs org UserFuncAddr dsk bin/texinfotags use macros/standard; da NullVect ;jump here for start file processing. da TeXTag? ;jump here for IsTag? and tag processing. da NullVect ;jump here for end-of-file processing.;NullVect rts; put tagprocs/tag.subs;; Given a line which contains something like:;;     @chapter Using the MAKETAGS Progam;; Make a tag which looks like:;;     Using the MAKETAGS Program!@chapter !;TeXTag? equ *  ;check LineBuff for texinfo tag. lda LineBuff ;any characters here? beq :fail ;no text, no tag. lda LineBuff+1 ;check for special starting character. cmp #"@" beq :find_token ;a tag begins with an atsign.;:fail lda #$FF rts;:find_token ldx #$02 ;prepare LineIndex for call to NextToken. stx LineIndex;; Get the next word, and see if it is one of the special ones.; jsr NextToken lda Token ;does this token have any length? beq :fail ;no.  Not a tag.;; We have a word in Token that could be special.  Check it out.; load :list;Specials ;point to the list of string pointers.;; Scan through the list of strings, comparing each one against; Token.  If a match is found, then the remainder of that line; is the tag.  The list is terminated with a pointer to $0000.;:check_loop move :list;temp ;get pointer to list in temp.; ldy #$00 ;get the pointer to the string in temp. lda (temp),y tax iny lda (temp),y sta temp+1 stx temp ora temp ;check to see if at end of list. beq :fail ;not special.;; Compare the string in temp against the string in Token.  If; they match, then the remainder of the line is the tag, and; the line up to the point that we're at now, is the; tag-leader.; jsr CompareToken beq :extract_tag;; The token just compared wasn't special.  Try the next one in; the list.;:next_list lda :list clc adc #$02 sta :list lda :list+1 adc #$00 sta :list+1 jmp :check_loop;; We have found a line with a tag.  Extract it from the line,; and make a tag out of it.;:extract_tag;; Append whitespace to the end of :appendage.  Also find start; of label.; ldx LineIndex ;pointer to just after the token read. ldy Token:append cpx LineBuff ;at last character now? bcs :fail ;yes, so no tag on this line. lda LineBuff,x ;is this character whitespace? jsr WhiteSpace? bne :append_x ;no, so at start of label. iny sta Token,y inx bne :append;:append_x lda #"!" iny sta Token,y sty Token;; Eat the rest of this line as the label.  Just place it; directly at Tag.; ldy #$01:eat_label lda LineBuff,x sta Tag,y cpx LineBuff bcs :finish; inx iny bne :eat_label;:finish iny lda #"!" sta Tag,y iny lda #"@" sta Tag,y ldx #$00:final iny lda Token+1,x sta Tag,y inx cpx Token bcc :final sty Tag:win lda #$00 ;win.  Return BEQ. rts:list da $0000 ;pointer to list of string pointers.Specials equ *  ;pointers to special strings.; da tx_Chapter da tx_Sec da tx_SubSec da tx_SubSubSec da tx_UnChapter da tx_UnSection da tx_UnSubSec da tx_UnSubSub da tx_Appendix da tx_Glossary da $0000;tx_Chapter str "Chapter"tx_Sec str "Section"tx_SubSec str "SubSection"tx_SubSubSec str "SubSubSection"tx_UnChapter str "Unnumbered"tx_UnSection str "UnnumberedSec"tx_UnSubSec str "UnnumberedSubSec"tx_UnSubSub str "UnnumberedSubSubSec"tx_Appendix str "Appendix"tx_Glossary str "Glossary";